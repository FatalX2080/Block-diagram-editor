Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport sys, math\r\nimport numpy as np\r\nfrom pygame.examples.go_over_there import event\r\n\r\npygame.init()\r\n\r\n\r\nclass BaseCanvasElement:\r\n    def __init__(self, x, y):\r\n        self.x = x\r\n        self.x = y\r\n\r\n\r\nclass Blocks(BaseCanvasElement):\r\n    def __init__(self, x, y, win, win_size, block_type):\r\n        self.x = x\r\n        self.y = y\r\n        self.window = win\r\n        self.win_size = win_size\r\n        self.block_type = block_type\r\n        # 1 - start; 2 - funk; 3 - if; 4 - out_funk; 5 - linker; 6 - for; 7 - stdin\r\n\r\n    def draw(self, k=1):\r\n        skale = (self.win_size[0] // 20 * k, self.win_size[1] // 20 * k)\r\n        match self.block_type:\r\n            case 1:\r\n                pygame.draw.rect(self.window, Gui.WHITE, (self.x, self.y, skale[0], skale[1]),\r\n                                 border_radius=2)\r\n                pygame.draw.rect(self.window, Gui.BLACK, (self.x, self.y, skale[0], skale[1]), 1,\r\n                                 border_radius=2)\r\n\r\n    def update_cords(self):\r\n        pass\r\n\r\n\r\nclass Gui:\r\n    WHITE = (255, 255, 255)\r\n    BLACK = (0, 0, 0)\r\n    GRAY = (160, 160, 160)\r\n    LIGHT_GRAY = (200, 200, 200)\r\n    DARK_GRAY = (100, 100, 100)\r\n\r\n    FONT = pygame.font.SysFont(None, 20)\r\n\r\n    class TabPosition:\r\n        def __init__(self, window_size):\r\n            ws = window_size\r\n\r\n            self.window_size = window_size\r\n            self.main_bg = (0, ws[1] * 0.05, ws[0] * 0.98, ws[1] * 0.90)\r\n            self.objects_block = (ws[0] * 0.004, ws[1] * 0.06, ws[0] * 0.15, ws[1] * 0.88)\r\n            self.canvas_size = (ws[0] * 0.818, ws[1] * 0.88)\r\n            self.canvas = (2 * self.objects_block[0] + self.objects_block[2], ws[1] * 0.06,\r\n                           self.canvas_size[0], self.canvas_size[1]\r\n                           )\r\n            self.info_block = (self.canvas[0] + self.canvas_size[0] - ws[0] * 0.144,\r\n                               self.canvas[1] + ws[1] * 0.004, ws[0] * 0.14, ws[1] * 0.38)\r\n\r\n    class Canvas:\r\n        def __init__(self, canvas_cords, win, tab_sizes):\r\n            self.user_cords = [10000, 10000]\r\n\r\n            self.tab_sizes = tab_sizes\r\n            self.canvas_cords = (canvas_cords[0], canvas_cords[1],\r\n                                 canvas_cords[0] + canvas_cords[2],\r\n                                 canvas_cords[1] + canvas_cords[3]\r\n                                 )\r\n            self.win = win\r\n            self.grid_step = 15\r\n\r\n        def is_in_sight(self, pos):\r\n            return self.canvas_cords[0] <= pos[0] <= self.canvas_cords[2] and \\\r\n                self.canvas_cords[1] <= pos[1] <= self.canvas_cords[2]\r\n\r\n        def update_cord(self, dx, dy):\r\n            self.user_cords[0] += dx\r\n            self.user_cords[1] += dy\r\n\r\n        def update(self):\r\n            hf_step = self.grid_step // 2 + 1\r\n\r\n            pygame.draw.rect(self.win, Gui.WHITE, self.tab_sizes.canvas)\r\n            pygame.draw.rect(self.win, Gui.DARK_GRAY, self.tab_sizes.canvas, 1)\r\n\r\n            relative_cords = (self.user_cords[0] - (self.canvas_cords[0] / 2),\r\n                              self.user_cords[1] - (self.canvas_cords[1] / 2))\r\n\r\n            net_start_point = [self.canvas_cords[_] + math.ceil(\r\n                relative_cords[_] / self.grid_step) * self.grid_step - relative_cords[_] for _ in (0, 1)]\r\n\r\n            grid_cords = [np.arange(\r\n                net_start_point[_] + hf_step, self.canvas_cords[2 + _] - self.grid_step, self.grid_step\r\n            ) for _ in (0, 1)]\r\n\r\n            for x in grid_cords[0]:\r\n                for y in grid_cords[1]:\r\n                    pygame.draw.circle(self.win, Gui.BLACK, (x, y), 1)\r\n\r\n            # Информационный блок\r\n            x = int(self.user_cords[0] - 10 ** 4)\r\n            y = int(self.user_cords[1] - 10 ** 4)\r\n            text = f\"X: {x} {' ' * (12 - len(str(x)))} Y: {y}\"\r\n            pygame.draw.rect(self.win, Gui.WHITE, self.tab_sizes.info_block)\r\n            pygame.draw.rect(self.win, Gui.DARK_GRAY, self.tab_sizes.info_block, 1)\r\n            self.win.blit(Gui.FONT.render(text, True, Gui.BLACK), (\r\n                self.tab_sizes.info_block[0] + self.tab_sizes.window_size[0] * 0.006,\r\n                self.tab_sizes.info_block[1] + self.tab_sizes.window_size[1] * 0.006))\r\n\r\n    def __init__(self, win_size=(1280, 720), fps=30):\r\n        self.running = True\r\n        self.win_size = win_size\r\n\r\n        self.canvas_capture = False\r\n        self.last_click_pos = (0, 0)\r\n        self.win = pygame.display.set_mode(self.win_size)\r\n\r\n        self.tab_sizes = self.TabPosition(self.win_size)\r\n        self.canvas = self.Canvas(self.tab_sizes.canvas, self.win, self.tab_sizes)\r\n        self.block1 = Blocks(500, 500, self.win, self.win_size, 1)\r\n\r\n        self.win.fill((255, 255, 255))\r\n        self.__initial_gui_rendering()\r\n        pygame.time.Clock().tick(fps)\r\n\r\n    def mainloop(self):\r\n        while self.running:\r\n            self.__event_update()\r\n            self.__rendering()\r\n\r\n    def __initial_gui_rendering(self):\r\n        # Основной задник\r\n        pygame.draw.rect(self.win, Gui.GRAY, self.tab_sizes.main_bg)\r\n\r\n        # Блок блоков\r\n        pygame.draw.rect(self.win, Gui.WHITE, self.tab_sizes.objects_block)\r\n        pygame.draw.rect(self.win, Gui.DARK_GRAY, self.tab_sizes.objects_block, 1)\r\n\r\n    def __rendering(self):\r\n        self.canvas.update()\r\n        self.block1.draw()\r\n        pygame.display.flip()\r\n\r\n    def __event_update(self):\r\n        for event in pygame.event.get():\r\n            match event.type:\r\n                case pygame.QUIT:\r\n                    pygame.quit()\r\n                    sys.exit()\r\n                case pygame.MOUSEBUTTONDOWN:\r\n                    if event.button == 1:\r\n                        if self.canvas.is_in_sight(event.pos):\r\n                            self.canvas_capture = True\r\n                            self.last_click_pos = event.pos\r\n                case pygame.MOUSEMOTION:\r\n                    dx, dy = [self.last_click_pos[_] - event.pos[_] for _ in (0, 1)]\r\n\r\n                    if self.canvas_capture:\r\n                        self.canvas.update_cord(dx, dy)\r\n                        #self.last_click_pos = event.pos\r\n                case pygame.MOUSEBUTTONUP:\r\n                    self.canvas_capture = False\r\n                    self.last_click_pos = event.pos\r\n\r\n\r\ndef main():\r\n    gui.mainloop()\r\n\r\n\r\ngui = Gui()\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 44a74386741667915335deb4b23ef1237a0fe239)
+++ b/main.py	(date 1727302982563)
@@ -1,37 +1,62 @@
 import pygame
 import sys, math
 import numpy as np
-from pygame.examples.go_over_there import event
 
 pygame.init()
 
 
-class BaseCanvasElement:
-    def __init__(self, x, y):
-        self.x = x
-        self.x = y
+class Blocks:
+    blocks = []
 
-
-class Blocks(BaseCanvasElement):
     def __init__(self, x, y, win, win_size, block_type):
         self.x = x
         self.y = y
+
         self.window = win
         self.win_size = win_size
         self.block_type = block_type
+
+        self.size = (self.win_size[0] // 20, self.win_size[1] // 20)
+
+        Blocks.blocks.append(self)
         # 1 - start; 2 - funk; 3 - if; 4 - out_funk; 5 - linker; 6 - for; 7 - stdin
 
     def draw(self, k=1):
-        skale = (self.win_size[0] // 20 * k, self.win_size[1] // 20 * k)
+
         match self.block_type:
             case 1:
-                pygame.draw.rect(self.window, Gui.WHITE, (self.x, self.y, skale[0], skale[1]),
-                                 border_radius=2)
-                pygame.draw.rect(self.window, Gui.BLACK, (self.x, self.y, skale[0], skale[1]), 1,
-                                 border_radius=2)
+                pygame.draw.rect(
+                    self.window, Gui.WHITE, (self.x, self.y, self.size[0] / k, self.size[1] / k), 0, 10
+                )
+                pygame.draw.rect(
+                    self.window, Gui.BLACK, (self.x, self.y, self.size[0] / k, self.size[1] / k), 1, 10
+                )
+            case 2:
+                pygame.draw.rect(
+                    self.window, Gui.WHITE, (self.x, self.y, self.size[0] / k, self.size[1] / k)
+                )
+                pygame.draw.rect(
+                    self.window, Gui.BLACK, (self.x, self.y, self.size[0] / k, self.size[1] / k), 1
+                )
+
+    def update_cords(self, dx, dy):
+        self.x -= dx
+        self.y -= dy
 
-    def update_cords(self):
-        pass
+    def capture_check(self, x, y):
+        return self.x <= x <= (self.x + self.size[0]) and self.y <= y <= (self.y + self.size[1])
+
+    @staticmethod
+    def update_all_cords(dx, dy):
+        for block in Blocks.blocks:
+            block.update_cords(dx, dy)
+
+    @staticmethod
+    def block_capture(x, y):
+        for block in Blocks.blocks:
+            if block.capture_chack(x, y):
+                return block
+        return None
 
 
 class Gui:
@@ -69,7 +94,7 @@
             self.win = win
             self.grid_step = 15
 
-        def is_in_sight(self, pos):
+        def capture_check(self, pos):
             return self.canvas_cords[0] <= pos[0] <= self.canvas_cords[2] and \
                 self.canvas_cords[1] <= pos[1] <= self.canvas_cords[2]
 
@@ -149,7 +174,7 @@
                     sys.exit()
                 case pygame.MOUSEBUTTONDOWN:
                     if event.button == 1:
-                        if self.canvas.is_in_sight(event.pos):
+                        if self.canvas.capture_check(event.pos):
                             self.canvas_capture = True
                             self.last_click_pos = event.pos
                 case pygame.MOUSEMOTION:
@@ -157,7 +182,8 @@
 
                     if self.canvas_capture:
                         self.canvas.update_cord(dx, dy)
-                        #self.last_click_pos = event.pos
+                        Blocks.update_all_cords(dx, dy)
+                        self.last_click_pos = event.pos
                 case pygame.MOUSEBUTTONUP:
                     self.canvas_capture = False
                     self.last_click_pos = event.pos
